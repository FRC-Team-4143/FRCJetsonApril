diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-imx219.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-imx219.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-imx219.dtsi	2023-03-19 09:52:55.000000000 -0500
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-imx219.dtsi	2023-08-17 13:48:26.467607069 -0500
@@ -94,6 +94,7 @@
 	cam_i2cmux {
 		i2c_0:i2c@0 {
 			imx219_cam0: rbpcv2_imx219_a@10 {
+				status = "disabled";
 				compatible = "sony,imx219";
 				/* I2C device address */
 				reg = <0x10>;
@@ -466,6 +467,7 @@
 		};
 		i2c_1: i2c@1 {
 			imx219_cam1: rbpcv2_imx219_c@10 {
+				status = "disabled";
 				compatible = "sony,imx219";
 				/* I2C device address */
 				reg = <0x10>;
@@ -817,7 +819,7 @@
 					port@0 {
 						reg = <0>;
 						rbpcv2_imx219_out1: endpoint {
-							status = "okay";
+							/*status = "okay"; */
 							port-index = <2>;
 							bus-width = <2>;
 							remote-endpoint = <&rbpcv2_imx219_csi_in1>;
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-ov9281.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-ov9281.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-ov9281.dtsi	1969-12-31 18:00:00.000000000 -0600
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-rbpcv2-ov9281.dtsi	2023-08-18 15:52:45.008958865 -0500
@@ -0,0 +1,514 @@
+/*
+ * Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <dt-bindings/media/camera.h>
+
+/ {
+	tegra-capture-vi  {
+		num-channels = <2>;
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			vi_port0: port@0 {
+				reg = <0>;
+				rbpcv2_ov9281_vi_in0: endpoint {
+					port-index = <0>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_ov9281_csi_out0>;
+				};
+			};
+			vi_port1: port@1 {
+				reg = <1>;
+				rbpcv2_ov9281_vi_in1: endpoint {
+					port-index = <2>;
+					bus-width = <2>;
+					remote-endpoint = <&rbpcv2_ov9281_csi_out1>;
+				};
+			};
+		};
+	};
+
+	host1x@13e00000 {
+		nvcsi@15a00000 {
+			num-channels = <2>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			csi_chan0: channel@0 {
+				reg = <0>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan0_port0: port@0 {
+						reg = <0>;
+						rbpcv2_ov9281_csi_in0: endpoint@0 {
+							port-index = <1>;  /* rjs <0> */
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_ov9281_out0>;
+						};
+					};
+					csi_chan0_port1: port@1 {
+						reg = <1>;
+						rbpcv2_ov9281_csi_out0: endpoint@1 {
+							remote-endpoint = <&rbpcv2_ov9281_vi_in0>;
+						};
+					};
+				};
+			};
+			csi_chan1: channel@1 {
+				reg = <1>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					csi_chan1_port0: port@0 {
+						reg = <0>;
+						rbpcv2_ov9281_csi_in1: endpoint@2 {
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_ov9281_out1>;
+						};
+					};
+					csi_chan1_port1: port@1 {
+						reg = <1>;
+						rbpcv2_ov9281_csi_out1: endpoint@3 {
+							remote-endpoint = <&rbpcv2_ov9281_vi_in1>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	cam_i2cmux {
+		i2c_0:i2c@0 {
+			ov9281_cam0: rbpcv2_ov9281_a@60 {
+				compatible = "ovti,ov9281";
+				/* I2C device address */
+				reg = <0x60>;
+
+				/*hzhy add */
+                                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+                                clock-names = "extperiph1";
+                                mclk = "extperiph1";
+				fsync = "none";
+
+				/* V4L2 device node location */
+				devnode = "video0";
+
+				/* Physical dimensions of sensor */
+				physical_w = "3.680";
+				physical_h = "2.760";
+
+				sensor_model = "ov9281";
+
+				use_sensor_mode_id = "false";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* lane_polarity
+				* Based on the camera connector pin.
+				* CSIx_D0 | CSIx_D1 | CSI(X+1)_D0 | CSI(X+1)CSIx_D1
+				*    LSB  |   BIT1  |     BIT2    |      MSB
+				* if there is a polarity swap on any lane, the bit corrsponding
+				* to the lane should be set
+				* e.g. polarity swap on CSIx_D0 only -> lane_polarity = "1"; 0001
+				* e.g. polarity swap on CSIx_D1 and CSI(X+1)_D0 -> lane_polarity = "6"; 0110
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* OV9281_MODE_1280x720_120FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_a";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes"; /* yes rjs */
+					dpcm_enable = "false";
+					cil_settletime = "0";
+					lane_polarity = "6";
+
+					active_w = "1280";
+					active_h = "720";
+					mode_type = "bayer";
+					pixel_phase = "rggb";
+					csi_pixel_bit_depth = "10";
+					readout_orientation = "90";
+					line_length = "1355"; /* 1408 rjs */
+					inherent_gain = "1";
+					/*mclk_multiplier = "9.33";*/ /* 9.33 rjs */
+					pix_clk_hz = "130900000"; /* "74250000" ; */ /* 800000000 rjs */
+
+					gain_factor = "1";
+					framerate_factor = "1";
+					exposure_factor = "1";
+					min_gain_val = "1"; /* 1.00x */
+					max_gain_val = "8191"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+					min_framerate = "2000000"; /* 2.0 fps */
+					max_framerate = "120000000"; /* 120.0 fps */
+					step_framerate = "1";
+					default_framerate = "120000000"; /* 120.0 fps */
+					min_exp_time = "1"; /* us */
+					max_exp_time = "16777215"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "10896"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						rbpcv2_ov9281_out0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_ov9281_csi_in0>;
+						};
+					};
+				};
+			};
+		};
+		i2c_1: i2c@1 {
+			ov9281_cam1: rbpcv2_ov9281_c@60 {
+				compatible = "ovti,ov9281";
+				/* I2C device address */
+				reg = <0x60>;
+
+				/*hzhy add */
+                                clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH2>;
+                                clock-names = "extperiph2";
+                                mclk = "extperiph2";
+				fsync = "none";
+
+				/* V4L2 device node location */
+				devnode = "video1";
+
+				/* Physical dimensions of sensor */
+				physical_w = "3.680";
+				physical_h = "2.760";
+
+				sensor_model = "ov9281";
+
+				use_sensor_mode_id = "false";
+
+				/**
+				* ==== Modes ====
+				* A modeX node is required to support v4l2 driver
+				* implementation with NVIDIA camera software stack
+				*
+				* == Signal properties ==
+				*
+				* phy_mode = "";
+				* PHY mode used by the MIPI lanes for this device
+				*
+				* tegra_sinterface = "";
+				* CSI Serial interface connected to tegra
+				* Incase of virtual HW devices, use virtual
+				* For SW emulated devices, use host
+				*
+				* pix_clk_hz = "";
+				* Sensor pixel clock used for calculations like exposure and framerate
+				*
+				* readout_orientation = "0";
+				* Based on camera module orientation.
+				* Only change readout_orientation if you specifically
+				* Program a different readout order for this mode
+				*
+				* == Image format Properties ==
+				*
+				* active_w = "";
+				* Pixel active region width
+				*
+				* active_h = "";
+				* Pixel active region height
+				*
+				* pixel_t = "";
+				* The sensor readout pixel pattern
+				*
+				* line_length = "";
+				* Pixel line length (width) for sensor mode.
+				*
+				* == Source Control Settings ==
+				*
+				* Gain factor used to convert fixed point integer to float
+				* Gain range [min_gain/gain_factor, max_gain/gain_factor]
+				* Gain step [step_gain/gain_factor is the smallest step that can be configured]
+				* Default gain [Default gain to be initialized for the control.
+				*     use min_gain_val as default for optimal results]
+				* Framerate factor used to convert fixed point integer to float
+				* Framerate range [min_framerate/framerate_factor, max_framerate/framerate_factor]
+				* Framerate step [step_framerate/framerate_factor is the smallest step that can be configured]
+				* Default Framerate [Default framerate to be initialized for the control.
+				*     use max_framerate to get required performance]
+				* Exposure factor used to convert fixed point integer to float
+				* For convenience use 1 sec = 1000000us as conversion factor
+				* Exposure range [min_exp_time/exposure_factor, max_exp_time/exposure_factor]
+				* Exposure step [step_exp_time/exposure_factor is the smallest step that can be configured]
+				* Default Exposure Time [Default exposure to be initialized for the control.
+				*     Set default exposure based on the default_framerate for optimal exposure settings]
+				*
+				* gain_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_gain_val = ""; (ceil to integer)
+				* max_gain_val = ""; (ceil to integer)
+				* step_gain_val = ""; (ceil to integer)
+				* default_gain = ""; (ceil to integer)
+				* Gain limits for mode
+				*
+				* exposure_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_exp_time = ""; (ceil to integer)
+				* max_exp_time = ""; (ceil to integer)
+				* step_exp_time = ""; (ceil to integer)
+				* default_exp_time = ""; (ceil to integer)
+				* Exposure Time limits for mode (sec)
+				*
+				* framerate_factor = ""; (integer factor used for floating to fixed point conversion)
+				* min_framerate = ""; (ceil to integer)
+				* max_framerate = ""; (ceil to integer)
+				* step_framerate = ""; (ceil to integer)
+				* default_framerate = ""; (ceil to integer)
+				* Framerate limits for mode (fps)
+				*
+				* embedded_metadata_height = "";
+				* Sensor embedded metadata height in units of rows.
+				* If sensor does not support embedded metadata value should be 0.
+				*/
+				mode0 { /* OV9281_MODE_1280x720_120FPS */
+					mclk_khz = "24000";
+					num_lanes = "2";
+					tegra_sinterface = "serial_c";
+					phy_mode = "DPHY";
+					discontinuous_clk = "yes"; /* yes rjs */
+					dpcm_enable = "false";
+					cil_settletime = "0";
+					lane_polarity = "0";
+
+					active_w = "1280";
+					active_h = "720";
+					mode_type = "bayer";
+					pixel_phase = "rggb";
+					csi_pixel_bit_depth = "10";
+					readout_orientation = "90";
+					line_length = "1355"; /*1408*/
+					inherent_gain = "1";
+					/*mclk_multiplier = "9.33";*/ /* 9.33 rjs */
+					pix_clk_hz = "130900000"; /* "74250000" ; */ /* 800000000 rjs */
+
+					gain_factor = "1";
+					framerate_factor = "1";
+					exposure_factor = "1";
+					min_gain_val = "1"; /* 1.00x */
+					max_gain_val = "8191"; /* 10.66x */
+					step_gain_val = "1";
+					default_gain = "16"; /* 1.00x */
+					min_hdr_ratio = "1";
+					max_hdr_ratio = "1";
+					min_framerate = "2000000"; /* 2.0 fps */
+					max_framerate = "120000000"; /* 120.0 fps */
+					step_framerate = "1";
+					default_framerate = "120000000"; /* 120.0 fps */
+					min_exp_time = "1"; /* us */
+					max_exp_time = "16777215"; /* us */
+					step_exp_time = "1";
+					default_exp_time = "10896"; /* us */
+
+					embedded_metadata_height = "0";
+				};
+
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						rbpcv2_ov9281_out1: endpoint {
+							/*status = "okay"; */
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&rbpcv2_ov9281_csi_in1>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	lens_ov9281@RBPCV2 {
+		min_focus_distance = "0.0";
+		hyper_focal = "0.0";
+		focal_length = "3.04";
+		f_number = "2.0";
+		aperture = "0.0";
+	};
+};
+/ {
+	tcp: tegra-camera-platform {
+		compatible = "nvidia, tegra-camera-platform";
+		/**
+		* Physical settings to calculate max ISO BW
+		*
+		* num_csi_lanes = <>;
+		* Total number of CSI lanes when all cameras are active
+		*
+		* max_lane_speed = <>;
+		* Max lane speed in Kbit/s
+		*
+		* min_bits_per_pixel = <>;
+		* Min bits per pixel
+		*
+		* vi_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the VI ISO case
+		*
+		* vi_bw_margin_pct = <>;
+		* Vi bandwidth margin in percentage
+		*
+		* max_pixel_rate = <>;
+		* Max pixel rate in Kpixel/s for the ISP ISO case
+		*
+		* isp_peak_byte_per_pixel = <>;
+		* Max byte per pixel for the ISP ISO case
+		*
+		* isp_bw_margin_pct = <>;
+		* Isp bandwidth margin in percentage
+		*/
+		num_csi_lanes = <4>;
+		max_lane_speed = <1500000>;
+		min_bits_per_pixel = <8>;
+		vi_peak_byte_per_pixel = <2>;
+		vi_bw_margin_pct = <25>;
+		max_pixel_rate = <240000>;
+		isp_peak_byte_per_pixel = <5>;
+		isp_bw_margin_pct = <25>;
+
+		/**
+		 * The general guideline for naming badge_info contains 3 parts, and is as follows,
+		 * The first part is the camera_board_id for the module; if the module is in a FFD
+		 * platform, then use the platform name for this part.
+		 * The second part contains the position of the module, ex. "rear" or "front".
+		 * The third part contains the last 6 characters of a part number which is found
+		 * in the module's specsheet from the vendor.
+		 */
+		modules {
+			cam_module0: module0 {
+				badge = "jakku_front_RBP194";
+				position = "front";
+				orientation = "1";
+				cam_module0_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "ov9281 9-0060";
+					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv2_ov9281_a@60";
+				};
+				cam_module0_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_ov9281@RBPCV2/";
+				};
+			};
+			cam_module1: module1 {
+				badge = "jakku_rear_RBP194";
+				position = "rear";
+				orientation = "1";
+				cam_module1_drivernode0: drivernode0 {
+					pcl_id = "v4l2_sensor";
+					devname = "ov9281 10-0060";
+					proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv2_ov9281_c@60";
+				};
+				cam_module1_drivernode1: drivernode1 {
+					pcl_id = "v4l2_lens";
+					proc-device-tree = "/proc/device-tree/lens_ov9281@RBPCV2/";
+				};
+			};
+		};
+	};
+};
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi	2023-03-19 09:52:55.000000000 -0500
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi	2023-08-16 15:10:52.457525859 -0500
@@ -18,6 +18,7 @@
 #include "tegra234-p3509-audio.dtsi"
 #include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
 #include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-p3768-camera-rbpcv2-ov9281.dtsi"
 
 / {
 	gpio-keys {
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi	2023-03-19 09:52:55.000000000 -0500
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi	2023-08-17 13:30:53.447972277 -0500
@@ -18,6 +18,7 @@
 #include "tegra234-p3768-audio.dtsi"
 #include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
 #include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-p3768-camera-rbpcv2-ov9281.dtsi"
 
 / {
 	gpio-keys {
@@ -273,7 +274,8 @@
 
 	host1x@13e00000 {
 		nvcsi@15a00000 {
-			csi_chan0 {
+			channel@0 {
+			/*csi_chan0 { RJS */
 				ports {
 					port@0 {
 						endpoint@0 {
@@ -287,7 +289,7 @@
 
 	cam_i2cmux{
 		i2c@0 {
-			rbpcv2_imx219_a@10 {
+			 rbpcv2_imx219_a@10 {
 				mode0 {
 					tegra_sinterface = "serial_b";
 					lane_polarity = "6";
@@ -308,6 +310,20 @@
 					tegra_sinterface = "serial_b";
 					lane_polarity = "6";
 				};
+				ports {
+					port@0 {
+						endpoint {
+							port-index = <1>;
+						};
+					};
+				};
+			};
+
+			rbpcv2_ov9281_a@60 {
+				mode0 {
+					tegra_sinterface = "serial_b";
+					lane_polarity = "6";
+				};
 				ports {
 					port@0 {
 						endpoint {
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-imx219.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-imx219.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-imx219.dtsi	2023-03-19 09:52:55.000000000 -0500
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-imx219.dtsi	2023-08-17 13:51:02.221954272 -0500
@@ -23,14 +23,14 @@
 
 / {
 	cam_i2cmux{
-		status = "okay";
+		status = "disabled";
 		compatible = "i2c-mux-gpio";
 		#address-cells = <1>;
 		#size-cells = <0>;
 		i2c-parent = <&cam_i2c>;
 		mux-gpios = <&tegra_aon_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
 		i2c@0 {
-			status = "okay";
+			status = "disabled";
 			reg = <0>;
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -39,7 +39,7 @@
 			};
 		};
 		i2c@1 {
-			status = "okay";
+			status = "disabled";
 			reg = <1>;
 			#address-cells = <1>;
 			#size-cells = <0>;
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-ov9281.dtsi orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-ov9281.dtsi
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-ov9281.dtsi	1969-12-31 18:00:00.000000000 -0600
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-camera-rbpcv2-ov9281.dtsi	2023-08-16 22:10:54.772422858 -0500
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "tegra234-camera-rbpcv2-ov9281.dtsi"
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(AC, 0)
+#define CAM_I2C_MUX 	TEGRA234_AON_GPIO(CC, 3)
+
+/ {
+	cam_i2cmux{
+		status = "okay";
+		compatible = "i2c-mux-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		i2c-parent = <&cam_i2c>;
+		mux-gpios = <&tegra_aon_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+		i2c@0 {
+			status = "okay";
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			rbpcv2_ov9281_a@60 {
+				reset-gpios = <&tegra_main_gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+		i2c@1 {
+			status = "okay";
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			rbpcv2_ov9281_c@60 {
+				reset-gpios = <&tegra_main_gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+
+	gpio@2200000 {
+		camera-control-output-low {
+			gpio-hog;
+			output-low;
+			gpios = <CAM0_PWDN 0 CAM1_PWDN 0>;
+			label = "cam0-pwdn","cam1-pwdn";
+		};
+	};
+};
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/Makefile orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/Makefile
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/Makefile	2023-03-19 09:52:55.000000000 -0500
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/Makefile	2023-08-16 15:44:07.859081908 -0500
@@ -39,6 +39,8 @@
 dtbo-$(BUILD_ENABLE) += tegra234-p3767-camera-p3768-imx219-dual.dtbo
 dtbo-$(BUILD_ENABLE) += tegra234-p3767-camera-p3768-imx477-dual.dtbo
 dtbo-$(BUILD_ENABLE) += tegra234-p3767-camera-p3768-imx477-dual-4lane.dtbo
+dtbo-$(BUILD_ENABLE) += tegra234-p3767-camera-ov9281-dual.dtbo
+dtbo-$(BUILD_ENABLE) += tegra234-p3767-camera-p3768-ov9281-dual.dtbo
 dtbo-$(BUILD_ENABLE) += tegra234-p3767-overlay.dtbo
 
 ifneq ($(dtb-y),)
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-ov9281-dual.dts orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-ov9281-dual.dts
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-ov9281-dual.dts	1969-12-31 18:00:00.000000000 -0600
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-ov9281-dual.dts	2023-08-16 15:17:14.436699060 -0500
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Jetson Device-tree overlay for dual camera OV9281 rbpcv2 on dual
+ * cam connector baseboards
+ *
+ * Copyright (c) 2022-2023 NVIDIA CORPORATION. All rights reserved.
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-common/jetson/tegra234-p3767-0000-common.h>
+
+/ {
+	overlay-name = "Camera OV9281 Dual";
+	jetson-header-name = "Jetson Nano CSI Connector";
+	compatible = JETSON_COMPATIBLE_P3509;
+
+	/* ov9281 dual sensor module */
+	fragment@0 {
+		target = <&ov9281_cam0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@1 {
+		target = <&cam_module0>;
+		__overlay__ {
+			status = "okay";
+			badge = "jakku_front_RBP194";
+			position = "front";
+			orientation = "1";
+		};
+	};
+	fragment@2 {
+		target = <&cam_module0_drivernode0>;
+		__overlay__ {
+			status = "okay";
+			pcl_id = "v4l2_sensor";
+			devname = "ov9281 9-0060";
+			proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv2_ov9281_a@60";
+		};
+	};
+	fragment@3 {
+		target = <&ov9281_cam1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@4 {
+		target = <&cam_module1>;
+		__overlay__ {
+			status = "okay";
+			badge = "jakku_rear_RBP194";
+			position = "rear";
+			orientation = "1";
+		};
+	};
+	fragment@5 {
+		target = <&cam_module1_drivernode0>;
+		__overlay__ {
+			status = "okay";
+			pcl_id = "v4l2_sensor";
+			devname = "ov9281 10-0060";
+			proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv2_ov9281_c@60";
+		};
+	};
+	fragment@6 {
+		target = <&rbpcv2_ov9281_vi_in0>;
+		__overlay__ {
+			status = "okay";
+			port-index = <0>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_csi_out0>;
+		};
+	};
+	fragment@7 {
+		target = <&rbpcv2_ov9281_vi_in1>;
+		__overlay__ {
+			status = "okay";
+			port-index = <2>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_csi_out1>;
+		};
+	};
+	fragment@8 {
+		target = <&rbpcv2_ov9281_csi_in0>;
+		__overlay__ {
+			status = "okay";
+			port-index = <0>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_out0>;
+		};
+	};
+	fragment@9 {
+		target = <&rbpcv2_ov9281_csi_out0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@10 {
+		target = <&rbpcv2_ov9281_csi_in1>;
+		__overlay__ {
+			status = "okay";
+			port-index = <2>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_out1>;
+		};
+	};
+	fragment@12 {
+		target = <&rbpcv2_ov9281_csi_out1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff -ruN orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-p3768-ov9281-dual.dts orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-p3768-ov9281-dual.dts
--- orinorig/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-p3768-ov9281-dual.dts	1969-12-31 18:00:00.000000000 -0600
+++ orinmod/hardware/nvidia/platform/t23x/p3768/kernel-dts/tegra234-p3767-camera-p3768-ov9281-dual.dts	2023-08-16 15:43:35.162128967 -0500
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Jetson Device-tree overlay for dual camera OV9281 rbpcv2 on dual
+ * cam connector baseboards
+ *
+ * Copyright (c) 2022-2023 NVIDIA CORPORATION. All rights reserved.
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-common/jetson/tegra234-p3767-0000-common.h>
+
+/ {
+	overlay-name = "Camera OV9281 Dual";
+	jetson-header-name = "Jetson 24pin CSI Connector";
+	compatible = JETSON_COMPATIBLE_P3768;
+
+	/* OV9281 dual sensor module */
+	fragment@0 {
+		target = <&ov9281_cam0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@1 {
+		target = <&cam_module0>;
+		__overlay__ {
+			status = "okay";
+			badge = "jakku_front_RBP194";
+			position = "front";
+			orientation = "1";
+		};
+	};
+	fragment@2 {
+		target = <&cam_module0_drivernode0>;
+		__overlay__ {
+			status = "okay";
+			pcl_id = "v4l2_sensor";
+			devname = "ov9281 9-0060";
+			proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/rbpcv2_ov9281_a@60";
+		};
+	};
+	fragment@3 {
+		target = <&ov9281_cam1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@4 {
+		target = <&cam_module1>;
+		__overlay__ {
+			status = "okay";
+			badge = "jakku_rear_RBP194";
+			position = "rear";
+			orientation = "1";
+		};
+	};
+	fragment@5 {
+		target = <&cam_module1_drivernode0>;
+		__overlay__ {
+			status = "okay";
+			pcl_id = "v4l2_sensor";
+			devname = "ov9281 10-0060";
+			proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/rbpcv2_ov9281_c@60";
+		};
+	};
+	fragment@6 {
+		target = <&rbpcv2_ov9281_vi_in0>;
+		__overlay__ {
+			status = "okay";
+			port-index = <1>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_csi_out0>;
+		};
+	};
+	fragment@7 {
+		target = <&rbpcv2_ov9281_vi_in1>;
+		__overlay__ {
+			status = "okay";
+			port-index = <2>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_csi_out1>;
+		};
+	};
+	fragment@8 {
+		target = <&rbpcv2_ov9281_csi_in0>;
+		__overlay__ {
+			status = "okay";
+			port-index = <1>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_out0>;
+		};
+	};
+	fragment@9 {
+		target = <&rbpcv2_ov9281_csi_out0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+	fragment@10 {
+		target = <&rbpcv2_ov9281_csi_in1>;
+		__overlay__ {
+			status = "okay";
+			port-index = <2>;
+			bus-width = <2>;
+			remote-endpoint = <&rbpcv2_ov9281_out1>;
+		};
+	};
+	fragment@12 {
+		target = <&rbpcv2_ov9281_csi_out1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff -ruN orinorig/kernel/nvidia/drivers/media/i2c/nv_ov9281.c orinmod/kernel/nvidia/drivers/media/i2c/nv_ov9281.c
--- orinorig/kernel/nvidia/drivers/media/i2c/nv_ov9281.c	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/media/i2c/nv_ov9281.c	2023-08-18 15:50:15.382240503 -0500
@@ -19,6 +19,7 @@
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
 #include <linux/module.h>
+#include <linux/i2c.h>
 #include <linux/version.h>
 
 #include <linux/seq_file.h>
@@ -98,18 +99,38 @@
 #define OV9281_DEFAULT_EXPOSURE_COARSE	0x00002A90
 
 #define OV9281_MAX_WIDTH		1280
-#define OV9281_MAX_HEIGHT		800
+#define OV9281_MAX_HEIGHT		720
 
 #define OV9281_DEFAULT_MODE		OV9281_MODE_1280X800
 #define OV9281_DEFAULT_WIDTH		OV9281_MAX_WIDTH
 #define OV9281_DEFAULT_HEIGHT		OV9281_MAX_HEIGHT
 #define OV9281_DEFAULT_DATAFMT		MEDIA_BUS_FMT_SBGGR10_1X10
-#define OV9281_DEFAULT_CLK_FREQ		26000000
+/*#define OV9281_DEFAULT_DATAFMT		MEDIA_BUS_FMT_SRGGB8_1X8*/
+/*#define OV9281_DEFAULT_DATAFMT		MEDIA_BUS_FMT_Y8_1X8 */
+/*#define OV9281_DEFAULT_DATAFMT		MEDIA_BUS_FMT_Y10_1X10 */
+#define OV9281_DEFAULT_CLK_FREQ		24000000
 
 #define OV9281_DEFAULT_I2C_ADDRESS_C0		(0xc0 >> 1)
 #define OV9281_DEFAULT_I2C_ADDRESS_20		(0x20 >> 1)
 #define OV9281_DEFAULT_I2C_ADDRESS_PROGRAMMABLE	(0xe0 >> 1)
 
+static int sensor_mode = 4;  // 0 for 10bit 1 for 8bit
+
+struct inno_rom_table {
+        char magic[12];
+        char manuf[32];
+        u16 manuf_id;
+        char sen_manuf[8];
+        char sen_type[16];
+        u16 mod_id;
+        u16 mod_rev;
+        char regs[56];
+        u16 nr_modes;
+        u16 bytes_per_mode;
+        char mode1[16];
+        char mode2[16];
+};
+
 struct ov9281 {
 	struct camera_common_power_rail	power;
 	int				num_ctrls;
@@ -130,9 +151,60 @@
 	struct regmap			*regmap;
 	struct camera_common_data	*s_data;
 	struct camera_common_pdata	*pdata;
+	struct i2c_client               *rom;
+	struct inno_rom_table           rom_table;
 	struct v4l2_ctrl		*ctrls[];
 };
 
+static int rom_write(struct i2c_client *client, const u8 addr, const u8 data)
+{
+        struct i2c_adapter *adap = client->adapter;
+        struct i2c_msg msg;
+        u8 tx[2];
+        int ret;
+
+        msg.addr = client->addr;
+        msg.buf = tx;
+        msg.len = 2;
+        msg.flags = 0;
+        tx[0] = addr;
+        tx[1] = data;
+        ret = i2c_transfer(adap, &msg, 1);
+        mdelay(2);
+
+        return ret == 1 ? 0 : -EIO;
+}
+
+static int rom_read(struct i2c_client *client, const u8 addr)
+{
+        u8 buf[1]={ addr };
+        int ret;
+        struct i2c_msg msgs[] = {
+                {
+                        .addr  = client->addr,
+                        .flags = 0,
+                        .len   = 1,
+                        .buf   = buf,
+                }, {
+                        .addr  = client->addr,
+                        .flags = I2C_M_RD,
+                        .len   = 1,
+                        .buf   = buf,
+                },
+        };
+
+        ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+        if (ret < 0) {
+                dev_warn(&client->dev, "Reading register %x from %x failed\n",
+                         addr, client->addr);
+                return ret;
+        }
+
+        return buf[0];
+}
+
+
+
 /* Register/regmap stuff */
 static int ov9281_read_reg(struct camera_common_data *s_data, u16 addr, u8 *val)
 {
@@ -1169,9 +1241,16 @@
 	struct camera_common_data *common_data;
 	struct device *dev = &client->dev;
 	struct ov9281 *priv;
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
 	int err;
 
-	dev_info(dev, "probing v4l2 sensor.\n");
+	dev_info(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+        if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+                dev_warn(&adapter->dev,
+                         "I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");
+        }
+
 
 	common_data = devm_kzalloc(dev, sizeof(*common_data), GFP_KERNEL);
 
@@ -1185,6 +1264,81 @@
 		return -ENOMEM;
 	}
 
+	priv->rom = i2c_new_dummy_device(adapter,0x10);  /*_device*/
+        if ( priv->rom )
+         {
+                static int i=1;
+                int addr,reg,data;
+                dev_info(&client->dev, "InnoMaker Camera controller found!\n");
+#if 1
+                for (addr=0; addr<sizeof(priv->rom_table); addr++)
+                {
+                  reg = rom_read(priv->rom, addr);
+                  *((char *)(&(priv->rom_table))+addr)=(char)reg;
+                  dev_dbg(&client->dev, "addr=0x%04x reg=0x%02x\n",addr,reg);
+                }
+
+                dev_info(&client->dev, "[ MAGIC  ] [ %s ]\n",
+                                priv->rom_table.magic);
+
+                dev_info(&client->dev, "[ MANUF. ] [ %s ] [ MID=0x%04x ]\n",
+                                priv->rom_table.manuf,
+                                priv->rom_table.manuf_id);
+
+                dev_info(&client->dev, "[ SENSOR ] [ %s %s ]\n",
+                                priv->rom_table.sen_manuf,
+                                priv->rom_table.sen_type);
+
+                dev_info(&client->dev, "[ MODULE ] [ ID=0x%04x ] [ REV=0x%04x ]\n",
+                                priv->rom_table.mod_id,
+                                priv->rom_table.mod_rev);
+
+                dev_info(&client->dev, "[ MODES  ] [ NR=0x%04x ] [ BPM=0x%04x ]\n",
+                                priv->rom_table.nr_modes,
+                                priv->rom_table.bytes_per_mode);
+#endif
+                addr = 200; // reset
+                data =   2; // powerdown sensor
+                reg = rom_write(priv->rom, addr, data);
+
+                addr = 202; // mode
+                data = sensor_mode; // default 8-bit streaming
+                reg = rom_write(priv->rom, addr, data);
+
+                //addr = 200; // reset
+                //data =   0; // powerup sensor
+                //reg = reg_write(priv->rom, addr, data);
+
+                while(1)
+                {
+                        mdelay(100); // wait 100ms
+
+                        addr = 201; // status
+                        reg = rom_read(priv->rom, addr);
+
+                        if(reg & 0x80)
+                                break;
+
+                        if(reg & 0x01)
+                                dev_err(&client->dev, "!!! ERROR !!! setting  Sensor MODE=%d STATUS=0x%02x i=%d\n",sensor_mode,reg,i);
+
+                        if(i++ >  4)
+                                break;
+                }
+
+                dev_info(&client->dev, " Sensor MODE=%d PowerOn STATUS=0x%02x i=%d\n",sensor_mode,reg,i);
+
+        }
+        else
+        {
+
+                dev_err(&client->dev, "NOTE !!!  External Camera controller  not found !!!\n");
+                dev_info(&client->dev, "Sensor MODE=%d \n",sensor_mode);
+                return -EIO;
+        }
+
+
+
 	priv->regmap = devm_regmap_init_i2c(client, &ov9281_regmap_config);
 	if (IS_ERR(priv->regmap)) {
 		dev_err(dev, "regmap init failed %ld\n", PTR_ERR(priv->regmap));
diff -ruN orinorig/kernel/nvidia/drivers/media/i2c/ov9281_mode_tbls.h orinmod/kernel/nvidia/drivers/media/i2c/ov9281_mode_tbls.h
--- orinorig/kernel/nvidia/drivers/media/i2c/ov9281_mode_tbls.h	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/media/i2c/ov9281_mode_tbls.h	2023-08-18 15:47:02.962744664 -0500
@@ -28,8 +28,8 @@
 
 enum {
 	OV9281_MODE_1280X800,
-	OV9281_MODE_1280X720,
-	OV9281_MODE_640X400,
+	/*OV9281_MODE_1280X720,
+	OV9281_MODE_640X400, */
 	OV9281_MODE_START_STREAM,
 	OV9281_MODE_STOP_STREAM,
 };
@@ -74,6 +74,7 @@
 	{ OV9281_TABLE_END, 0x00 }
 };
 
+#if 0
 static const ov9281_reg ov9281_mode_1280x800_26MhzMCLK[] = {
 	/* PLL control */
 	{ 0x0302, 0x32 },
@@ -219,7 +220,10 @@
 	{ 0x4f13, 0xc4 },
 	{ OV9281_TABLE_END, 0x00 }
 };
+#endif
 
+
+#if 0
 static const ov9281_reg ov9281_mode_1280x800_26MhzMCLK_fsync_slave[] = {
 	{ 0x3826, 0x03 }, /* R reset value on fsin.  VTS - 4 */
 	{ 0x3827, 0x8a },
@@ -437,19 +441,33 @@
 	{ 0x3827, 0x04 },
 	{ OV9281_TABLE_END, 0x00 }
 };
+#endif
+
+static const ov9281_reg ov9281_mode_1280x800_24MhzMCLK_fsync_slave[] = {
+       { 0x3826, 0x03 }, /* R reset value on fsin.  VTS - 4 */
+       { 0x3827, 0x8a },
+       { OV9281_TABLE_END, 0x00 }
+};
+
+static const ov9281_reg ov9281_mode_1280x800_24MhzMCLK[] = {
+       {OV9281_TABLE_END, 0x00 }
+};
+
 
 static const ov9281_reg *ov9281_mode_table[] = {
-	[OV9281_MODE_1280X800] = ov9281_mode_1280x800_26MhzMCLK,
+	[OV9281_MODE_1280X800] = ov9281_mode_1280x800_24MhzMCLK,
+	/*[OV9281_MODE_1280X800] = ov9281_mode_1280x800_26MhzMCLK,
 	[OV9281_MODE_1280X720] = ov9281_mode_1280x720_26MhzMCLK,
-	[OV9281_MODE_640X400] = ov9281_mode_640x400_26MhzMCLK,
+	[OV9281_MODE_640X400] = ov9281_mode_640x400_26MhzMCLK, */
 	[OV9281_MODE_START_STREAM] = ov9281_start,
 	[OV9281_MODE_STOP_STREAM] = ov9281_stop,
 };
 
 static const ov9281_reg *ov9281_fsync_slave_mode_table[] = {
-	[OV9281_MODE_1280X800] = ov9281_mode_1280x800_26MhzMCLK_fsync_slave,
+	[OV9281_MODE_1280X800] = ov9281_mode_1280x800_24MhzMCLK_fsync_slave,
+	/*[OV9281_MODE_1280X800] = ov9281_mode_1280x800_26MhzMCLK_fsync_slave,
 	[OV9281_MODE_1280X720] = ov9281_mode_1280x720_26MhzMCLK_fsync_slave,
-	[OV9281_MODE_640X400] = ov9281_mode_640x400_26MhzMCLK_fsync_slave,
+	[OV9281_MODE_640X400] = ov9281_mode_640x400_26MhzMCLK_fsync_slave, */
 };
 
 static const ov9281_reg *ov9281_fsync_table[] = {
@@ -462,13 +480,25 @@
 	60,
 };
 
+static const int ov9281_120fps[] = {
+       120,
+};
+
+static const int ov9281_144fps[] = {
+       144,
+};
+
 static const struct camera_common_frmfmt ov9281_frmfmt[] = {
-	{ { 1280, 800 }, ov9281_60fps, ARRAY_SIZE(ov9281_60fps), 0,
+	/*{ { 1280, 800 }, ov9281_144fps, ARRAY_SIZE(ov9281_144fps), 0,
+	  OV9281_MODE_1280X800 },*/
+	{ { 1280, 720 }, ov9281_120fps, ARRAY_SIZE(ov9281_120fps), 0,
+	  OV9281_MODE_1280X800 },
+	/*{ { 1280, 800 }, ov9281_60fps, ARRAY_SIZE(ov9281_60fps), 0,
 	  OV9281_MODE_1280X800 },
 	{ { 1280, 720 }, ov9281_60fps, ARRAY_SIZE(ov9281_60fps), 0,
 	  OV9281_MODE_1280X720 },
 	{ { 640, 400 }, ov9281_60fps, ARRAY_SIZE(ov9281_60fps), 0,
-	  OV9281_MODE_640X400 },
+	  OV9281_MODE_640X400 }, */
 };
 
 #endif  /* __OV9281_I2C_TABLES__ */
diff -ruN orinorig/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c orinmod/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c
--- orinorig/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c	2023-07-05 16:03:25.708340990 -0500
@@ -131,6 +131,25 @@
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_VYUY,
 	},
+	// Grayscale 8bit support
+       {
+               MEDIA_BUS_FMT_Y8_1X8,
+               V4L2_COLORSPACE_RAW,
+               V4L2_PIX_FMT_GREY,
+       },
+       // Grayscale 10bit support
+       {
+               MEDIA_BUS_FMT_Y10_1X10,
+               V4L2_COLORSPACE_RAW,
+               V4L2_PIX_FMT_Y10,
+       },
+       // Grayscale 12bit support
+       {
+               MEDIA_BUS_FMT_Y12_1X12,
+               V4L2_COLORSPACE_RAW,
+               V4L2_PIX_FMT_Y12,
+       },
+
 	/*
 	 * The below two formats are not supported by VI4,
 	 * keep them at the last to ensure they get discarded
diff -ruN orinorig/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c orinmod/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
--- orinorig/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2023-08-16 17:31:35.728826771 -0500
@@ -237,6 +237,8 @@
 
 	if (strncmp(pixel_t, "bayer_bggr10", size) == 0)
 		*format = V4L2_PIX_FMT_SBGGR10;
+	else if (strncmp(pixel_t, "bayer_rggb8", size) == 0)
+		*format = V4L2_PIX_FMT_SRGGB8;
 	else if (strncmp(pixel_t, "bayer_rggb10", size) == 0)
 		*format = V4L2_PIX_FMT_SRGGB10;
 	else if (strncmp(pixel_t, "bayer_grbg10", size) == 0)
@@ -273,6 +275,12 @@
 		*format = V4L2_PIX_FMT_UYVY;
 	else if (strncmp(pixel_t, "yuv_vyuy16", size) == 0)
 		*format = V4L2_PIX_FMT_VYUY;
+	else if (strncmp(pixel_t, "raw_y88", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "raw_y1010", size) == 0)
+		*format = V4L2_PIX_FMT_Y10;
+	else if (strncmp(pixel_t, "raw_y1212", size) == 0)
+		*format = V4L2_PIX_FMT_Y12;
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
diff -ruN orinorig/kernel/nvidia/drivers/misc/eventlib/Makefile orinmod/kernel/nvidia/drivers/misc/eventlib/Makefile
--- orinorig/kernel/nvidia/drivers/misc/eventlib/Makefile	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/misc/eventlib/Makefile	2023-08-15 17:14:01.214460920 -0500
@@ -13,7 +13,8 @@
 # Copyright (c) 2017, NVIDIA CORPORATION.  All rights reserved.
 #
 
-ccflags-y += -Werror
+#RJS
+ccflags-y += -Werror -mno-outline-atomics
 
 obj-$(CONFIG_EVENTLIB) := eventlib-kernel.o
 
diff -ruN orinorig/kernel/nvidia/drivers/net/ethernet/nvidia/nvethernet/Makefile orinmod/kernel/nvidia/drivers/net/ethernet/nvidia/nvethernet/Makefile
--- orinorig/kernel/nvidia/drivers/net/ethernet/nvidia/nvethernet/Makefile	2023-03-19 09:53:53.000000000 -0500
+++ orinmod/kernel/nvidia/drivers/net/ethernet/nvidia/nvethernet/Makefile	2023-08-15 17:10:07.399873144 -0500
@@ -21,7 +21,9 @@
 obj-$(CONFIG_NVETHERNET) += nvethernet.o
 
 # These CFLAGS must not be shared/used in OSI. These are local to Linux
+# RJS
 ccflags-y +=  -DLINUX_OS -DNET30 -DNVPKCS_MACSEC -DLINUX_IVC -DUPDATED_PAD_CAL \
+	      -mno-outline-atomics \
               -I$(srctree.nvidia)/drivers/net/ethernet/nvidia/nvethernet/nvethernetrm/include \
 	     -I$(srctree.nvidia)/drivers/net/ethernet/nvidia/nvethernet/nvethernetrm/osi/common/include
 
