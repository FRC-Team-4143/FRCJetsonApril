// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CALIBRATION_FRC971_VISION_CALIBRATION_H_
#define FLATBUFFERS_GENERATED_CALIBRATION_FRC971_VISION_CALIBRATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 10 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace frc971 {
namespace vision {
namespace calibration {

struct TransformationMatrix;
struct TransformationMatrixBuilder;
struct TransformationMatrixT;

struct CameraCalibration;
struct CameraCalibrationBuilder;
struct CameraCalibrationT;

struct CalibrationData;
struct CalibrationDataBuilder;
struct CalibrationDataT;

bool operator==(const TransformationMatrixT &lhs, const TransformationMatrixT &rhs);
bool operator!=(const TransformationMatrixT &lhs, const TransformationMatrixT &rhs);
bool operator==(const CameraCalibrationT &lhs, const CameraCalibrationT &rhs);
bool operator!=(const CameraCalibrationT &lhs, const CameraCalibrationT &rhs);
bool operator==(const CalibrationDataT &lhs, const CalibrationDataT &rhs);
bool operator!=(const CalibrationDataT &lhs, const CalibrationDataT &rhs);

inline const flatbuffers::TypeTable *TransformationMatrixTypeTable();

inline const flatbuffers::TypeTable *CameraCalibrationTypeTable();

inline const flatbuffers::TypeTable *CalibrationDataTypeTable();

struct TransformationMatrixT : public flatbuffers::NativeTable {
  typedef TransformationMatrix TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.TransformationMatrixT";
  }
  std::vector<float> data{};
};

struct TransformationMatrix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformationMatrixT NativeTableType;
  typedef TransformationMatrixBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransformationMatrixTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.TransformationMatrix";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  flatbuffers::Vector<float> *mutable_data() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_DATA);
  }
  void clear_data() {
    ClearField(VT_DATA);
  }
  bool has_data() const {
    return CheckField(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  TransformationMatrixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformationMatrixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransformationMatrix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformationMatrixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformationMatrixBuilder {
  typedef TransformationMatrix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(TransformationMatrix::VT_DATA, data);
  }
  explicit TransformationMatrixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransformationMatrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformationMatrix>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformationMatrix> CreateTransformationMatrix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  TransformationMatrixBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

struct TransformationMatrix::Traits {
  using type = TransformationMatrix;
  static auto constexpr Create = CreateTransformationMatrix;
};

inline flatbuffers::Offset<TransformationMatrix> CreateTransformationMatrixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return frc971::vision::calibration::CreateTransformationMatrix(
      _fbb,
      data__);
}

flatbuffers::Offset<TransformationMatrix> CreateTransformationMatrix(flatbuffers::FlatBufferBuilder &_fbb, const TransformationMatrixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraCalibrationT : public flatbuffers::NativeTable {
  typedef CameraCalibration TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.CameraCalibrationT";
  }
  std::string node_name{};
  int32_t team_number = 0;
  std::vector<float> intrinsics{};
  flatbuffers::unique_ptr<frc971::vision::calibration::TransformationMatrixT> fixed_extrinsics{};
  flatbuffers::unique_ptr<frc971::vision::calibration::TransformationMatrixT> turret_extrinsics{};
  std::vector<float> dist_coeffs{};
  int64_t calibration_timestamp = 0;
  std::string camera_id{};
  int32_t camera_number = 0;
  float reprojection_error = 0.0f;
  CameraCalibrationT() = default;
  CameraCalibrationT(const CameraCalibrationT &o);
  CameraCalibrationT(CameraCalibrationT&&) FLATBUFFERS_NOEXCEPT = default;
  CameraCalibrationT &operator=(CameraCalibrationT o) FLATBUFFERS_NOEXCEPT;
};

struct CameraCalibration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraCalibrationT NativeTableType;
  typedef CameraCalibrationBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CameraCalibrationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.CameraCalibration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_NAME = 4,
    VT_TEAM_NUMBER = 6,
    VT_INTRINSICS = 8,
    VT_FIXED_EXTRINSICS = 10,
    VT_TURRET_EXTRINSICS = 12,
    VT_DIST_COEFFS = 14,
    VT_CALIBRATION_TIMESTAMP = 16,
    VT_CAMERA_ID = 18,
    VT_CAMERA_NUMBER = 20,
    VT_REPROJECTION_ERROR = 22
  };
  const flatbuffers::String *node_name() const {
    return GetPointer<const flatbuffers::String *>(VT_NODE_NAME);
  }
  flatbuffers::String *mutable_node_name() {
    return GetPointer<flatbuffers::String *>(VT_NODE_NAME);
  }
  void clear_node_name() {
    ClearField(VT_NODE_NAME);
  }
  bool has_node_name() const {
    return CheckField(VT_NODE_NAME);
  }
  int32_t team_number() const {
    return GetField<int32_t>(VT_TEAM_NUMBER, 0);
  }
  bool mutate_team_number(int32_t _team_number = 0) {
    return SetField<int32_t>(VT_TEAM_NUMBER, _team_number, 0);
  }
  void clear_team_number() {
    ClearField(VT_TEAM_NUMBER);
  }
  bool has_team_number() const {
    return CheckField(VT_TEAM_NUMBER);
  }
  const flatbuffers::Vector<float> *intrinsics() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INTRINSICS);
  }
  flatbuffers::Vector<float> *mutable_intrinsics() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_INTRINSICS);
  }
  void clear_intrinsics() {
    ClearField(VT_INTRINSICS);
  }
  bool has_intrinsics() const {
    return CheckField(VT_INTRINSICS);
  }
  const frc971::vision::calibration::TransformationMatrix *fixed_extrinsics() const {
    return GetPointer<const frc971::vision::calibration::TransformationMatrix *>(VT_FIXED_EXTRINSICS);
  }
  frc971::vision::calibration::TransformationMatrix *mutable_fixed_extrinsics() {
    return GetPointer<frc971::vision::calibration::TransformationMatrix *>(VT_FIXED_EXTRINSICS);
  }
  void clear_fixed_extrinsics() {
    ClearField(VT_FIXED_EXTRINSICS);
  }
  bool has_fixed_extrinsics() const {
    return CheckField(VT_FIXED_EXTRINSICS);
  }
  const frc971::vision::calibration::TransformationMatrix *turret_extrinsics() const {
    return GetPointer<const frc971::vision::calibration::TransformationMatrix *>(VT_TURRET_EXTRINSICS);
  }
  frc971::vision::calibration::TransformationMatrix *mutable_turret_extrinsics() {
    return GetPointer<frc971::vision::calibration::TransformationMatrix *>(VT_TURRET_EXTRINSICS);
  }
  void clear_turret_extrinsics() {
    ClearField(VT_TURRET_EXTRINSICS);
  }
  bool has_turret_extrinsics() const {
    return CheckField(VT_TURRET_EXTRINSICS);
  }
  const flatbuffers::Vector<float> *dist_coeffs() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DIST_COEFFS);
  }
  flatbuffers::Vector<float> *mutable_dist_coeffs() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_DIST_COEFFS);
  }
  void clear_dist_coeffs() {
    ClearField(VT_DIST_COEFFS);
  }
  bool has_dist_coeffs() const {
    return CheckField(VT_DIST_COEFFS);
  }
  int64_t calibration_timestamp() const {
    return GetField<int64_t>(VT_CALIBRATION_TIMESTAMP, 0);
  }
  bool mutate_calibration_timestamp(int64_t _calibration_timestamp = 0) {
    return SetField<int64_t>(VT_CALIBRATION_TIMESTAMP, _calibration_timestamp, 0);
  }
  void clear_calibration_timestamp() {
    ClearField(VT_CALIBRATION_TIMESTAMP);
  }
  bool has_calibration_timestamp() const {
    return CheckField(VT_CALIBRATION_TIMESTAMP);
  }
  const flatbuffers::String *camera_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CAMERA_ID);
  }
  flatbuffers::String *mutable_camera_id() {
    return GetPointer<flatbuffers::String *>(VT_CAMERA_ID);
  }
  void clear_camera_id() {
    ClearField(VT_CAMERA_ID);
  }
  bool has_camera_id() const {
    return CheckField(VT_CAMERA_ID);
  }
  int32_t camera_number() const {
    return GetField<int32_t>(VT_CAMERA_NUMBER, 0);
  }
  bool mutate_camera_number(int32_t _camera_number = 0) {
    return SetField<int32_t>(VT_CAMERA_NUMBER, _camera_number, 0);
  }
  void clear_camera_number() {
    ClearField(VT_CAMERA_NUMBER);
  }
  bool has_camera_number() const {
    return CheckField(VT_CAMERA_NUMBER);
  }
  float reprojection_error() const {
    return GetField<float>(VT_REPROJECTION_ERROR, 0.0f);
  }
  bool mutate_reprojection_error(float _reprojection_error = 0.0f) {
    return SetField<float>(VT_REPROJECTION_ERROR, _reprojection_error, 0.0f);
  }
  void clear_reprojection_error() {
    ClearField(VT_REPROJECTION_ERROR);
  }
  bool has_reprojection_error() const {
    return CheckField(VT_REPROJECTION_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_NAME) &&
           verifier.VerifyString(node_name()) &&
           VerifyField<int32_t>(verifier, VT_TEAM_NUMBER, 4) &&
           VerifyOffset(verifier, VT_INTRINSICS) &&
           verifier.VerifyVector(intrinsics()) &&
           VerifyOffset(verifier, VT_FIXED_EXTRINSICS) &&
           verifier.VerifyTable(fixed_extrinsics()) &&
           VerifyOffset(verifier, VT_TURRET_EXTRINSICS) &&
           verifier.VerifyTable(turret_extrinsics()) &&
           VerifyOffset(verifier, VT_DIST_COEFFS) &&
           verifier.VerifyVector(dist_coeffs()) &&
           VerifyField<int64_t>(verifier, VT_CALIBRATION_TIMESTAMP, 8) &&
           VerifyOffset(verifier, VT_CAMERA_ID) &&
           verifier.VerifyString(camera_id()) &&
           VerifyField<int32_t>(verifier, VT_CAMERA_NUMBER, 4) &&
           VerifyField<float>(verifier, VT_REPROJECTION_ERROR, 4) &&
           verifier.EndTable();
  }
  CameraCalibrationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraCalibrationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CameraCalibration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraCalibrationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraCalibrationBuilder {
  typedef CameraCalibration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_name(flatbuffers::Offset<flatbuffers::String> node_name) {
    fbb_.AddOffset(CameraCalibration::VT_NODE_NAME, node_name);
  }
  void add_team_number(int32_t team_number) {
    fbb_.AddElement<int32_t>(CameraCalibration::VT_TEAM_NUMBER, team_number, 0);
  }
  void add_intrinsics(flatbuffers::Offset<flatbuffers::Vector<float>> intrinsics) {
    fbb_.AddOffset(CameraCalibration::VT_INTRINSICS, intrinsics);
  }
  void add_fixed_extrinsics(flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> fixed_extrinsics) {
    fbb_.AddOffset(CameraCalibration::VT_FIXED_EXTRINSICS, fixed_extrinsics);
  }
  void add_turret_extrinsics(flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> turret_extrinsics) {
    fbb_.AddOffset(CameraCalibration::VT_TURRET_EXTRINSICS, turret_extrinsics);
  }
  void add_dist_coeffs(flatbuffers::Offset<flatbuffers::Vector<float>> dist_coeffs) {
    fbb_.AddOffset(CameraCalibration::VT_DIST_COEFFS, dist_coeffs);
  }
  void add_calibration_timestamp(int64_t calibration_timestamp) {
    fbb_.AddElement<int64_t>(CameraCalibration::VT_CALIBRATION_TIMESTAMP, calibration_timestamp, 0);
  }
  void add_camera_id(flatbuffers::Offset<flatbuffers::String> camera_id) {
    fbb_.AddOffset(CameraCalibration::VT_CAMERA_ID, camera_id);
  }
  void add_camera_number(int32_t camera_number) {
    fbb_.AddElement<int32_t>(CameraCalibration::VT_CAMERA_NUMBER, camera_number, 0);
  }
  void add_reprojection_error(float reprojection_error) {
    fbb_.AddElement<float>(CameraCalibration::VT_REPROJECTION_ERROR, reprojection_error, 0.0f);
  }
  explicit CameraCalibrationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraCalibration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraCalibration>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraCalibration> CreateCameraCalibration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> node_name = 0,
    int32_t team_number = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> intrinsics = 0,
    flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> fixed_extrinsics = 0,
    flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> turret_extrinsics = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> dist_coeffs = 0,
    int64_t calibration_timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> camera_id = 0,
    int32_t camera_number = 0,
    float reprojection_error = 0.0f) {
  CameraCalibrationBuilder builder_(_fbb);
  builder_.add_calibration_timestamp(calibration_timestamp);
  builder_.add_reprojection_error(reprojection_error);
  builder_.add_camera_number(camera_number);
  builder_.add_camera_id(camera_id);
  builder_.add_dist_coeffs(dist_coeffs);
  builder_.add_turret_extrinsics(turret_extrinsics);
  builder_.add_fixed_extrinsics(fixed_extrinsics);
  builder_.add_intrinsics(intrinsics);
  builder_.add_team_number(team_number);
  builder_.add_node_name(node_name);
  return builder_.Finish();
}

struct CameraCalibration::Traits {
  using type = CameraCalibration;
  static auto constexpr Create = CreateCameraCalibration;
};

inline flatbuffers::Offset<CameraCalibration> CreateCameraCalibrationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *node_name = nullptr,
    int32_t team_number = 0,
    const std::vector<float> *intrinsics = nullptr,
    flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> fixed_extrinsics = 0,
    flatbuffers::Offset<frc971::vision::calibration::TransformationMatrix> turret_extrinsics = 0,
    const std::vector<float> *dist_coeffs = nullptr,
    int64_t calibration_timestamp = 0,
    const char *camera_id = nullptr,
    int32_t camera_number = 0,
    float reprojection_error = 0.0f) {
  auto node_name__ = node_name ? _fbb.CreateString(node_name) : 0;
  auto intrinsics__ = intrinsics ? _fbb.CreateVector<float>(*intrinsics) : 0;
  auto dist_coeffs__ = dist_coeffs ? _fbb.CreateVector<float>(*dist_coeffs) : 0;
  auto camera_id__ = camera_id ? _fbb.CreateString(camera_id) : 0;
  return frc971::vision::calibration::CreateCameraCalibration(
      _fbb,
      node_name__,
      team_number,
      intrinsics__,
      fixed_extrinsics,
      turret_extrinsics,
      dist_coeffs__,
      calibration_timestamp,
      camera_id__,
      camera_number,
      reprojection_error);
}

flatbuffers::Offset<CameraCalibration> CreateCameraCalibration(flatbuffers::FlatBufferBuilder &_fbb, const CameraCalibrationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CalibrationDataT : public flatbuffers::NativeTable {
  typedef CalibrationData TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.CalibrationDataT";
  }
  std::vector<flatbuffers::unique_ptr<frc971::vision::calibration::CameraCalibrationT>> camera_calibrations{};
  CalibrationDataT() = default;
  CalibrationDataT(const CalibrationDataT &o);
  CalibrationDataT(CalibrationDataT&&) FLATBUFFERS_NOEXCEPT = default;
  CalibrationDataT &operator=(CalibrationDataT o) FLATBUFFERS_NOEXCEPT;
};

struct CalibrationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CalibrationDataT NativeTableType;
  typedef CalibrationDataBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CalibrationDataTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "frc971.vision.calibration.CalibrationData";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_CALIBRATIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> *camera_calibrations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> *>(VT_CAMERA_CALIBRATIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> *mutable_camera_calibrations() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> *>(VT_CAMERA_CALIBRATIONS);
  }
  void clear_camera_calibrations() {
    ClearField(VT_CAMERA_CALIBRATIONS);
  }
  bool has_camera_calibrations() const {
    return CheckField(VT_CAMERA_CALIBRATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAMERA_CALIBRATIONS) &&
           verifier.VerifyVector(camera_calibrations()) &&
           verifier.VerifyVectorOfTables(camera_calibrations()) &&
           verifier.EndTable();
  }
  CalibrationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CalibrationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CalibrationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CalibrationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CalibrationDataBuilder {
  typedef CalibrationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_calibrations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>>> camera_calibrations) {
    fbb_.AddOffset(CalibrationData::VT_CAMERA_CALIBRATIONS, camera_calibrations);
  }
  explicit CalibrationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CalibrationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CalibrationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CalibrationData> CreateCalibrationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>>> camera_calibrations = 0) {
  CalibrationDataBuilder builder_(_fbb);
  builder_.add_camera_calibrations(camera_calibrations);
  return builder_.Finish();
}

struct CalibrationData::Traits {
  using type = CalibrationData;
  static auto constexpr Create = CreateCalibrationData;
};

inline flatbuffers::Offset<CalibrationData> CreateCalibrationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> *camera_calibrations = nullptr) {
  auto camera_calibrations__ = camera_calibrations ? _fbb.CreateVector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>>(*camera_calibrations) : 0;
  return frc971::vision::calibration::CreateCalibrationData(
      _fbb,
      camera_calibrations__);
}

flatbuffers::Offset<CalibrationData> CreateCalibrationData(flatbuffers::FlatBufferBuilder &_fbb, const CalibrationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const TransformationMatrixT &lhs, const TransformationMatrixT &rhs) {
  return
      (lhs.data == rhs.data);
}

inline bool operator!=(const TransformationMatrixT &lhs, const TransformationMatrixT &rhs) {
    return !(lhs == rhs);
}


inline TransformationMatrixT *TransformationMatrix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TransformationMatrixT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransformationMatrix::UnPackTo(TransformationMatrixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline flatbuffers::Offset<TransformationMatrix> TransformationMatrix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformationMatrixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransformationMatrix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransformationMatrix> CreateTransformationMatrix(flatbuffers::FlatBufferBuilder &_fbb, const TransformationMatrixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransformationMatrixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _fbb.CreateVector(_o->data);
  return frc971::vision::calibration::CreateTransformationMatrix(
      _fbb,
      _data);
}


inline bool operator==(const CameraCalibrationT &lhs, const CameraCalibrationT &rhs) {
  return
      (lhs.node_name == rhs.node_name) &&
      (lhs.team_number == rhs.team_number) &&
      (lhs.intrinsics == rhs.intrinsics) &&
      ((lhs.fixed_extrinsics == rhs.fixed_extrinsics) || (lhs.fixed_extrinsics && rhs.fixed_extrinsics && *lhs.fixed_extrinsics == *rhs.fixed_extrinsics)) &&
      ((lhs.turret_extrinsics == rhs.turret_extrinsics) || (lhs.turret_extrinsics && rhs.turret_extrinsics && *lhs.turret_extrinsics == *rhs.turret_extrinsics)) &&
      (lhs.dist_coeffs == rhs.dist_coeffs) &&
      (lhs.calibration_timestamp == rhs.calibration_timestamp) &&
      (lhs.camera_id == rhs.camera_id) &&
      (lhs.camera_number == rhs.camera_number) &&
      (lhs.reprojection_error == rhs.reprojection_error);
}

inline bool operator!=(const CameraCalibrationT &lhs, const CameraCalibrationT &rhs) {
    return !(lhs == rhs);
}


inline CameraCalibrationT::CameraCalibrationT(const CameraCalibrationT &o)
      : node_name(o.node_name),
        team_number(o.team_number),
        intrinsics(o.intrinsics),
        fixed_extrinsics((o.fixed_extrinsics) ? new frc971::vision::calibration::TransformationMatrixT(*o.fixed_extrinsics) : nullptr),
        turret_extrinsics((o.turret_extrinsics) ? new frc971::vision::calibration::TransformationMatrixT(*o.turret_extrinsics) : nullptr),
        dist_coeffs(o.dist_coeffs),
        calibration_timestamp(o.calibration_timestamp),
        camera_id(o.camera_id),
        camera_number(o.camera_number),
        reprojection_error(o.reprojection_error) {
}

inline CameraCalibrationT &CameraCalibrationT::operator=(CameraCalibrationT o) FLATBUFFERS_NOEXCEPT {
  std::swap(node_name, o.node_name);
  std::swap(team_number, o.team_number);
  std::swap(intrinsics, o.intrinsics);
  std::swap(fixed_extrinsics, o.fixed_extrinsics);
  std::swap(turret_extrinsics, o.turret_extrinsics);
  std::swap(dist_coeffs, o.dist_coeffs);
  std::swap(calibration_timestamp, o.calibration_timestamp);
  std::swap(camera_id, o.camera_id);
  std::swap(camera_number, o.camera_number);
  std::swap(reprojection_error, o.reprojection_error);
  return *this;
}

inline CameraCalibrationT *CameraCalibration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CameraCalibrationT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraCalibration::UnPackTo(CameraCalibrationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_name(); if (_e) _o->node_name = _e->str(); }
  { auto _e = team_number(); _o->team_number = _e; }
  { auto _e = intrinsics(); if (_e) { _o->intrinsics.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intrinsics[_i] = _e->Get(_i); } } else { _o->intrinsics.resize(0); } }
  { auto _e = fixed_extrinsics(); if (_e) { if(_o->fixed_extrinsics) { _e->UnPackTo(_o->fixed_extrinsics.get(), _resolver); } else { _o->fixed_extrinsics = flatbuffers::unique_ptr<frc971::vision::calibration::TransformationMatrixT>(_e->UnPack(_resolver)); } } else if (_o->fixed_extrinsics) { _o->fixed_extrinsics.reset(); } }
  { auto _e = turret_extrinsics(); if (_e) { if(_o->turret_extrinsics) { _e->UnPackTo(_o->turret_extrinsics.get(), _resolver); } else { _o->turret_extrinsics = flatbuffers::unique_ptr<frc971::vision::calibration::TransformationMatrixT>(_e->UnPack(_resolver)); } } else if (_o->turret_extrinsics) { _o->turret_extrinsics.reset(); } }
  { auto _e = dist_coeffs(); if (_e) { _o->dist_coeffs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dist_coeffs[_i] = _e->Get(_i); } } else { _o->dist_coeffs.resize(0); } }
  { auto _e = calibration_timestamp(); _o->calibration_timestamp = _e; }
  { auto _e = camera_id(); if (_e) _o->camera_id = _e->str(); }
  { auto _e = camera_number(); _o->camera_number = _e; }
  { auto _e = reprojection_error(); _o->reprojection_error = _e; }
}

inline flatbuffers::Offset<CameraCalibration> CameraCalibration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraCalibrationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraCalibration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CameraCalibration> CreateCameraCalibration(flatbuffers::FlatBufferBuilder &_fbb, const CameraCalibrationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CameraCalibrationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_name = _o->node_name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->node_name);
  auto _team_number = _o->team_number;
  auto _intrinsics = _fbb.CreateVector(_o->intrinsics);
  auto _fixed_extrinsics = _o->fixed_extrinsics ? CreateTransformationMatrix(_fbb, _o->fixed_extrinsics.get(), _rehasher) : 0;
  auto _turret_extrinsics = _o->turret_extrinsics ? CreateTransformationMatrix(_fbb, _o->turret_extrinsics.get(), _rehasher) : 0;
  auto _dist_coeffs = _fbb.CreateVector(_o->dist_coeffs);
  auto _calibration_timestamp = _o->calibration_timestamp;
  auto _camera_id = _o->camera_id.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->camera_id);
  auto _camera_number = _o->camera_number;
  auto _reprojection_error = _o->reprojection_error;
  return frc971::vision::calibration::CreateCameraCalibration(
      _fbb,
      _node_name,
      _team_number,
      _intrinsics,
      _fixed_extrinsics,
      _turret_extrinsics,
      _dist_coeffs,
      _calibration_timestamp,
      _camera_id,
      _camera_number,
      _reprojection_error);
}


inline bool operator==(const CalibrationDataT &lhs, const CalibrationDataT &rhs) {
  return
      (lhs.camera_calibrations.size() == rhs.camera_calibrations.size() && std::equal(lhs.camera_calibrations.cbegin(), lhs.camera_calibrations.cend(), rhs.camera_calibrations.cbegin(), [](flatbuffers::unique_ptr<frc971::vision::calibration::CameraCalibrationT> const &a, flatbuffers::unique_ptr<frc971::vision::calibration::CameraCalibrationT> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const CalibrationDataT &lhs, const CalibrationDataT &rhs) {
    return !(lhs == rhs);
}


inline CalibrationDataT::CalibrationDataT(const CalibrationDataT &o) {
  camera_calibrations.reserve(o.camera_calibrations.size());
  for (const auto &camera_calibrations_ : o.camera_calibrations) { camera_calibrations.emplace_back((camera_calibrations_) ? new frc971::vision::calibration::CameraCalibrationT(*camera_calibrations_) : nullptr); }
}

inline CalibrationDataT &CalibrationDataT::operator=(CalibrationDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(camera_calibrations, o.camera_calibrations);
  return *this;
}

inline CalibrationDataT *CalibrationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CalibrationDataT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CalibrationData::UnPackTo(CalibrationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_calibrations(); if (_e) { _o->camera_calibrations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->camera_calibrations[_i]) { _e->Get(_i)->UnPackTo(_o->camera_calibrations[_i].get(), _resolver); } else { _o->camera_calibrations[_i] = flatbuffers::unique_ptr<frc971::vision::calibration::CameraCalibrationT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->camera_calibrations.resize(0); } }
}

inline flatbuffers::Offset<CalibrationData> CalibrationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CalibrationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCalibrationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CalibrationData> CreateCalibrationData(flatbuffers::FlatBufferBuilder &_fbb, const CalibrationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CalibrationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_calibrations = _fbb.CreateVector<flatbuffers::Offset<frc971::vision::calibration::CameraCalibration>> (_o->camera_calibrations.size(), [](size_t i, _VectorArgs *__va) { return CreateCameraCalibration(*__va->__fbb, __va->__o->camera_calibrations[i].get(), __va->__rehasher); }, &_va );
  return frc971::vision::calibration::CreateCalibrationData(
      _fbb,
      _camera_calibrations);
}

inline const flatbuffers::TypeTable *TransformationMatrixTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const char * const names[] = {
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CameraCalibrationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    frc971::vision::calibration::TransformationMatrixTypeTable
  };
  static const char * const names[] = {
    "node_name",
    "team_number",
    "intrinsics",
    "fixed_extrinsics",
    "turret_extrinsics",
    "dist_coeffs",
    "calibration_timestamp",
    "camera_id",
    "camera_number",
    "reprojection_error"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CalibrationDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    frc971::vision::calibration::CameraCalibrationTypeTable
  };
  static const char * const names[] = {
    "camera_calibrations"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const frc971::vision::calibration::CalibrationData *GetCalibrationData(const void *buf) {
  return flatbuffers::GetRoot<frc971::vision::calibration::CalibrationData>(buf);
}

inline const frc971::vision::calibration::CalibrationData *GetSizePrefixedCalibrationData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<frc971::vision::calibration::CalibrationData>(buf);
}

inline CalibrationData *GetMutableCalibrationData(void *buf) {
  return flatbuffers::GetMutableRoot<CalibrationData>(buf);
}

inline frc971::vision::calibration::CalibrationData *GetMutableSizePrefixedCalibrationData(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<frc971::vision::calibration::CalibrationData>(buf);
}

inline bool VerifyCalibrationDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<frc971::vision::calibration::CalibrationData>(nullptr);
}

inline bool VerifySizePrefixedCalibrationDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<frc971::vision::calibration::CalibrationData>(nullptr);
}

inline void FinishCalibrationDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<frc971::vision::calibration::CalibrationData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCalibrationDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<frc971::vision::calibration::CalibrationData> root) {
  fbb.FinishSizePrefixed(root);
}

inline flatbuffers::unique_ptr<frc971::vision::calibration::CalibrationDataT> UnPackCalibrationData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<frc971::vision::calibration::CalibrationDataT>(GetCalibrationData(buf)->UnPack(res));
}

inline flatbuffers::unique_ptr<frc971::vision::calibration::CalibrationDataT> UnPackSizePrefixedCalibrationData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<frc971::vision::calibration::CalibrationDataT>(GetSizePrefixedCalibrationData(buf)->UnPack(res));
}

}  // namespace calibration
}  // namespace vision
}  // namespace frc971

#endif  // FLATBUFFERS_GENERATED_CALIBRATION_FRC971_VISION_CALIBRATION_H_
